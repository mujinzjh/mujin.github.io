<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在mac下安装Nginx出现的问题</title>
      <link href="/2022/03/25/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Nginx%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/25/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Nginx%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装nginx之前首先需要安装homebrew</p><p>1.使用的是安装清华大学镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HoemebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure><p>2.安装通过brew –version 查看homebrew版本信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew --version</span><br></pre></td></tr></table></figure><p>3.安装Nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure><p>4.出现错误：</p><img src="/2022/03/25/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Nginx%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image.png" class><p>解析：最开始在网络上查找了多个解决办法，但是都没有办法解决。最后发现可能是执行错误。于是尝试一下的操作<br>安装红框中的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install openssl@1.1</span><br></pre></td></tr></table></figure><p>再次尝试安装nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure><p>中间正常安装，没有出现错误，到这里还不能说nginx正常安装了，为了防止安装出错。<br>查看nginx信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew info nginx</span><br></pre></td></tr></table></figure><p>运行nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start nginx</span><br></pre></td></tr></table></figure><p>运行成功！<br>在浏览器中输入localhost:8080,看到一下场景就知道nginx成功了！</p><img src="/2022/03/25/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Nginx%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image1.png" class>]]></content>
      
      
      <categories>
          
          <category> Mac - Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在mac下安装Nginx</title>
      <link href="/2022/03/25/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/"/>
      <url>/2022/03/25/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装-卸载Nginx"><a href="#一、安装-卸载Nginx" class="headerlink" title="一、安装/卸载Nginx"></a>一、安装/卸载Nginx</h1><p>安装Nginx（出现问题查看<a href="https://note.youdao.com/s/LJ9GXxuM%EF%BC%89">https://note.youdao.com/s/LJ9GXxuM）</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure><p>卸载Nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall nginx</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx / sudo brew services start nginx</span><br></pre></td></tr></table></figure><p>停止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s stop /sudo brew services stop nginx</span><br></pre></td></tr></table></figure><p>热重启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><p>强制停止Nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill -9 nginx</span><br></pre></td></tr></table></figure><p>修改配置<br>本机常用的文件路径：</p><ul><li>1./opt/homebrew/etc/nginx/nginx.conf（nginx配置文件路径）</li><li>2./opt/homebrew/var/www(nginx服务器默认的根目录)</li><li>3./opt/homebrew/var/log/nginx/error.log(nginx默认的日志路径)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 首尾配置暂时忽略</span><br><span class="line"></span><br><span class="line">server &#123;  </span><br><span class="line">        # 当nginx接到请求后，会匹配其配置中的service模块</span><br><span class="line">        # 匹配方法就是将请求携带的host和port去跟配置中的server_name和listen相匹配</span><br><span class="line">        listen       8080;        </span><br><span class="line">        server_name  localhost; # 定义当前虚拟主机（站点）匹配请求的主机名</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; # Nginx默认值</span><br><span class="line">            # 设定Nginx服务器返回的文档名</span><br><span class="line">            index  index.html index.htm; # 先找根目录下的index.html，如果没有再找index.htm</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 首尾配置暂时忽略</span><br></pre></td></tr></table></figure><p>当然 nginx 的配置非常多，用的时候可以根据文档进行配置。中文文档：<a href="https://www.nginx.cn/doc/">https://www.nginx.cn/doc/</a></p><h1 id="Nginx应用"><a href="#Nginx应用" class="headerlink" title="Nginx应用"></a>Nginx应用</h1><p>主要是4大应用</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><img src="/2022/03/25/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/2.jpg" class title="你想输入的替代文字"><p>如图所示：动静分离就是Nginx服务器将接收到的请求分为动态请求和静态请求。<br>静态请求直接从 nginx 服务器所设定的根目录路径去取对应的资源，动态请求转发给真实的后台（前面所说的应用服务器，如图中的Tomcat）去处理。<br>好处：<br>减少应用服务器的压力。<br>后台api接口服务化。<br>前后端分开并行开发和部署。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">    listen 8080; </span><br><span class="line">    server_name localhost; </span><br><span class="line">    location / &#123; </span><br><span class="line">        root html; # Nginx默认值</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125; </span><br><span class="line">    # 静态化配置，所有静态请求都转发给 nginx 处理，存放目录为 my-project </span><br><span class="line">    location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$ &#123; </span><br><span class="line">        root /usr/local/var/www/my-project; # 静态请求所代理到的根目录 </span><br><span class="line">   &#125; </span><br><span class="line">   # 动态请求匹配到path为&#x27;node&#x27;的就转发到8002端口处理 </span><br><span class="line">    location /node/ &#123;</span><br><span class="line">         proxy_pass http://localhost:8002; # 充当服务代理 </span><br><span class="line">    &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>访问静态资源nginx就会返回my-project中的文件<br>访问动态请求nginx服务器会将它从8002的端口请求返回回去。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>反向代理其实类似于你找代购买东西（浏览器或者其他终端向nginx请求），你不用管它去哪里买，只要买到东西就行了（浏览器或者其他终端最终拿到了想要的东西，但是具体从那儿拿到的过程它并不知道）。</p><h4 id="作用？"><a href="#作用？" class="headerlink" title="作用？"></a>作用？</h4><ul><li>保障应用服务器的安全（增加一层代理，可以屏蔽危险攻击，更方便的控制权限）。</li><li>实现负载均衡。</li><li>实现跨域。<br>配置简单的反向代理：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">        listen       8080;        </span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; # Nginx默认值</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://localhost:8000; # 反向代理配置，请求会被转发到8000端口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反向代理简单的模型：</p><img src="/2022/03/25/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/image.png" class title="你想输入的替代文字"><p>nginx就是充当图中的proxy，左边的3个client在请求时向nginx获取内容，感受不到server存在。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h4><p>在服务器集群中，Nginx可以将接收到的客户端的请求“均匀地”（可以通过设置权重）分配到这个集群中的所有的服务器上。这个就叫做负载均衡。<br>负载均衡的示意图如下：</p><img src="/2022/03/25/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/%E8%B4%9F%E8%BD%BD.png" class title="你想输入的替代文字"><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ul><li>分摊服务器集群压力。</li><li>保证客户端访问的稳定性。</li><li>负载均衡可以解决分摊服务器集群压力的问题。除此之外，Nginx还带有健康检查（服务器心跳检查）功能，会定期轮询向集群里的所有服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态。</li><li>一旦发现某台服务器异常，那么在这以后代理进来的客户端请求都不会被发送到该服务器上（直健康检查发现该服务器已恢复正常），从而保证客户端访问的稳定性。</li></ul><h5 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 负载均衡：设置domain</span><br><span class="line">upstream domain &#123;</span><br><span class="line">    server localhost:8000;</span><br><span class="line">    server localhost:8001;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;  </span><br><span class="line">        listen       8080;        </span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            # root   html; # Nginx默认值</span><br><span class="line">            # index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">            proxy_pass http://domain; # 负载均衡配置，请求会被平均分配到8000和8001端口</span><br><span class="line">            proxy_set_header Host $host:$server_port;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里有两个端口：8000和8001端口，负载均衡成功后访问localhost:8080有时候就会访问到8000端口的页面，有时候也会访问到8001端口的页面。<br>能有这个效果，说明负载均衡策略已经生效了。</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><h4 id="是什么？-2"><a href="#是什么？-2" class="headerlink" title="是什么？"></a>是什么？</h4><p>正向代理跟反向道理正好相反。拿上文中的那个代购例子来讲，多个人找代购购买同一个商品，代购找到买这个的店后一次性给买了。这个过程中，该店主是不知道代购是帮别代买买东西的。那么代购对于多个想买商品的顾客来讲，他就充当了正向代理。<br>意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理。<br>示意图如下：</p><img src="/2022/03/25/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" class title="你想输入的替代文字"><p>nginx就充当了图中的proxy，左边的3个 client 在请求时向 nginx 获取内容，server 是感受不到3台 client 存在的<br>科学上网VPN就是一个正向代理工具。</p>]]></content>
      
      
      <categories>
          
          <category> Mac - Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在react中使用history的问题</title>
      <link href="/2022/03/25/%E5%9C%A8react%E4%B8%AD%E4%BD%BF%E7%94%A8history%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/25/%E5%9C%A8react%E4%B8%AD%E4%BD%BF%E7%94%A8history%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="React中history问题记录"><a href="#React中history问题记录" class="headerlink" title="React中history问题记录"></a>React中history问题记录</h4><h5 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h5><p>在学习react的时候，创建了一个react+ts的项目框架。遇到一个问题，使用history无法进行页面跳转，即使跳转也无法渲染页面。</p><h5 id="二、创建项目"><a href="#二、创建项目" class="headerlink" title="二、创建项目"></a>二、创建项目</h5><p>使用以下语法创建了一个简单的项目框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app xxx --scripts-version=react-scripts-ts</span><br></pre></td></tr></table></figure><h4 id="三、history的用法"><a href="#三、history的用法" class="headerlink" title="三、history的用法"></a>三、history的用法</h4><ul><li>在react-router很大的程度上依赖history的功能。</li><li>history分为两类：BrowserHistory和HashHistory。分别对应的react-router-dom中的BrowserRouter和HashRouter 两个路由器。</li><li>在react-router很大的程度上依赖history的功能。</li><li>history分为两类：BrowserHistory和HashHistory。分别对应的react-router-dom中的BrowserRouter和HashRouter 两个路由器。</li></ul><h4 id="四、现象"><a href="#四、现象" class="headerlink" title="四、现象"></a>四、现象</h4><p>使用了Router这个路由器，传入history属性，但是在使用createHashHistory 和 createBrowserHistory创建的history时，出现了问题：</p><p><mark>路由发生了改变，页面并没有渲染。</mark></p><h4 id="五、原因"><a href="#五、原因" class="headerlink" title="五、原因"></a>五、原因</h4><p>react-router-dom是基于react-router进行开发的。在网上资料中找到：</p><p><img src="https://img2020.cnblogs.com/blog/1506521/202009/1506521-20200911163244585-439786497.png"></p><h4 id="六、解决方法"><a href="#六、解决方法" class="headerlink" title="六、解决方法"></a>六、解决方法</h4><p>降低history版本，就可以解决无法渲染问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install history@4.1.0 -D</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React - React问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> history </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
